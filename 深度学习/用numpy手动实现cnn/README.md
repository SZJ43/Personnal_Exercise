
# 2022.6.22

一、做项目时会碰到基础性函数，不能忽略掉，要去python终端亲手地做一做，真正地了解函数的运作机理。列一下今天实验函数

1. 关于np.sum函数

 import numpy as np
 
 a=np.arange(1, 28).reshape(3,3,3)
 
 print(a)


    [[[ 1  2  3]
      [ 4  5  6]
      [ 7  8  9]]

     [[10 11 12]
      [13 14 15]
      [16 17 18]]

     [[19 20 21]
      [22 23 24]
      [25 26 27]]]
  
 print(a.sum(axis=1))
 
    [[12 15 18]
     [39 42 45]
     [66 69 72]]
 
 print(a.sum(axis=0))
 
    [[30 33 36]
     [39 42 45]
     [48 51 54]]
 
print(a.sum(axis=2))
 
    [[ 6 15 24]
     [33 42 51]
     [60 69 78]]
 
 



2. 我对于np.sum后的axis是似是而非的懂了，但是真正让我去用的时候，可能会搞一个小时，还不一定搞得清楚。眼高手低是中国学生的通病，借助报道无需多展开。



3. 这个是一维的，但是我一直认为是十维的
 c = np.arange(1, 11)
  
 print(c)
 
    [ 1  2  3  4  5  6  7  8  9 10]

 print(c.shape)
 
    (10,)

4. 到现在不会用np.array， np.linspace

“加一层方括号”
 b = np.array([a])
 
 print(b.shape)
 
    (1, 10)

“生成列向量”
 b.reshape(10,1)

    array([[ 1.],
           [ 2.],
           [ 3.],
           [ 4.],
           [ 5.],
           [ 6.],
           [ 7.],
           [ 8.],
           [ 9.],
           [10.]])

5. 如果最外层是中括号里只有一个中括号，说明它的第一维度是1；如果最外层中括号里有10个中括号，说明它的第一维度是10. 如果1到10一个列表外边是三个中括号，那么它的shape我的回答是3 * 3 * 10，表明缺乏认识。首先，是1 * 1 * 10，第二可看出迁移能力较差。如果用苹果装袋子的比喻类比，是比较容易理解的



 d = np.array([[a]])
 
 print(d)
 
    [[[ 1  2  3  4  5  6  7  8  9 10]]]

 print(d.shape)
 
    (1, 1, 10)

6、一个中括号都不能差，第一部分最外层中括号里面又有三个由中括号括起来的部分

6.1 第一部分

    [[ 1  2  3]
     [ 4  5  6]
     [ 7  8  9]]
  
6.2 第二部分

    [[10 11 12]
     [13 14 15]
     [16 17 18]]

6.3 第三部分

    [[19 20 21]
     [22 23 24]
     [25 26 27]]
  
6.4 我现在已经明白，每退一层括号那么维度减少1个，就到了下一个维度的拆解。

 s = np.arange(1, 28).reshape(3,3,3)
 
 print(s)
 
    [[[ 1  2  3]
      [ 4  5  6]
      [ 7  8  9]]

    [[10 11 12]
     [13 14 15]
     [16 17 18]]

    [[19 20 21]
     [22 23 24]
     [25 26 27]]]
  
 7.
  
  7.1 生成3 * 3 * 3 * 3矩阵
  
  f = np.arange(1, 82).reshape(3,3,3,3)
 
  print(f)
 
    [[[[ 1  2  3]
       [ 4  5  6]
       [ 7  8  9]]

    [[10 11 12]
     [13 14 15]
     [16 17 18]]

    [[19 20 21]
     [22 23 24]
     [25 26 27]]]


    [[[28 29 30]
      [31 32 33]
      [34 35 36]]

    [[37 38 39]
     [40 41 42]
     [43 44 45]]

    [[46 47 48]
     [49 50 51]
     [52 53 54]]]


    [[[55 56 57]
      [58 59 60]
      [61 62 63]]

    [[64 65 66]
     [67 68 69]
     [70 71 72]]

    [[73 74 75]
     [76 77 78]
     [79 80 81]]]]
   
   7.2 相当于全国相加，最外层为全国的各省省会相加，其次是各个地级市之间相加，其次是市里面的区对应相加，最后是区里面的各个街道相加。
   
   
   2022.6.23
   
   7.3 如果axis为整数元组（x，y），则是求出axis=x和axis=y情况下得到的和。
   
   7.4 

 np.sum(b, axis=(0,1))


    array([117, 126, 135])

 np.sum(b, axis=0)


    array([[30, 33, 36],
           [39, 42, 45],
           [48, 51, 54]])
       
 np.sum(b, axis=1)


    array([[12, 15, 18],
           [39, 42, 45],
           [66, 69, 72]])
       
 print(b)


    [[[ 1  2  3]
      [ 4  5  6]
      [ 7  8  9]]

     [[10 11 12]
      [13 14 15]
      [16 17 18]]

      [[19 20 21]
      [22 23 24]
      [25 26 27]]]
  
 c = np.sum(b, axis=0)
 
 print(c)


    [[30 33 36]
     [39 42 45]
     [48 51 54]]
 
 c


    array([[30, 33, 36],
           [39, 42, 45],
           [48, 51, 54]])
        
 a


    array([[[ 1,  2,  3],
            [ 4,  5,  6],
            [ 7,  8,  9]],

            [[10, 11, 12],
             [13, 14, 15],
             [16, 17, 18]],

            [[19, 20, 21],
             [22, 23, 24],
             [25, 26, 27]]])
        
 d = np.sum(c, axis=1)
 
 d
 
    array([ 99, 126, 153])

 e = np.sum(c, axis=0)
 
 e
 
    array([117, 126, 135])
    
 7.5 对0维相加，是对3个大块的对应位置相加，得到2维数组。解释一下就是，19架战机对应的同等的东西相加，19架压缩成一架，每一架中是19个对应元素之和。比如有19架雷达相加之和。
    
 机翼：主翼、水平尾翼、垂直尾翼
    
 系统：控制系统、导航系统、发动机系统
    
 雷达：火控雷达、气象雷达、预警雷达
    
>>> np.sum(a, axis=1)
    
    array([[12, 15, 18],
           [39, 42, 45],
           [66, 69, 72]])
           
>>> np.sum(a, axis=2)
    
    array([[ 6, 15, 24],
           [33, 42, 51],
           [60, 69, 78]])
       
>>> np.sum(a, axis=0)
 
    array([[30, 33, 36],
           [39, 42, 45],
           [48, 51, 54]])
       
>>> np.sum(a, axis=(0,1))
 
    array([117, 126, 135])

>>> np.sum(a, axis=(0,2))
 
    array([99, 126, 153])

0维就是数组最外层

axis = (0,1)就是先对0维相加，再对得出结果的1维对应相加

axis = (0,2)就是先对0维相加，再对得出结果的2维对应相加


# 2022.6.26

1. shape是（2，3，4）的 和 shape是（2，4）的数组相乘会出错，不能用广播机制。但加np.newaxis可以用广播机制。newaxis对应的列是不变的。
   但（2，3，4）可以与（2，1，4）相乘，对于2个战斗机，每个战斗机用一个不同的shape为（1，4）的数组去乘每个战斗机的3个（1，4）。


2. shape是（2，3，4）的数组和shape是（2，3）的数组相乘会出错
但是如果在（2，3）的最后一个维度加上newaxis，变为（2，3，1），是可以相乘的。对于2个战斗机，每个战斗机用一个不同的shape为（3，1）的数组去乘以4列（个）（3，1），4列分别是雷达、机翼、系统。

    >>> a*c[:,:,np.newaxis]
    array([[[ 0.1,  0.2,  0.3,  0.4],
            [ 1. ,  1.2,  1.4,  1.6],
            [ 2.7,  3. ,  3.3,  3.6]],

           [[ 5.2,  5.6,  6. ,  6.4],
            [ 8.5,  9. ,  9.5, 10. ],
            [12.6, 13.2, 13.8, 14.4]]])
    >>> c
    array([[0.1, 0.2, 0.3],
           [0.4, 0.5, 0.6]])
    >>> a
    array([[[ 1.,  2.,  3.,  4.],
            [ 5.,  6.,  7.,  8.],
            [ 9., 10., 11., 12.]],

           [[13., 14., 15., 16.],
            [17., 18., 19., 20.],
            [21., 22., 23., 24.]]])
            
            
 3. shape是（2，3，4）的数组和shape是（3，4）的数组相乘不会出错，这是广播机制的直接应用,当然也可以在第一维度加newaxis，和不加是一样的效果。如果第一维是需要加newaxis才能实现广播机制的，这个Newaxis可以不加。但如果在最后一维，必须要加newaxis，如果不加就要出错。


4. 一个卷积核一个偏置，b就是长度为卷积核长度的向量

# 2022.6.27
1. 重复是学习之母
2. 120行背过

# 2022.7.6
每个点公用1个，有64个24*24这样大的数组，每一个进行相乘，同样复制1个.
>>> c = [[b[0],b[0],b[0]], [b[1],b[1],b[1]]]
>>> c
[[array([0.1, 0.2, 0.3, 0.4]), array([0.1, 0.2, 0.3, 0.4]), array([0.1, 0.2, 0.3, 0.4])], [array([0.5, 0.6, 0.7, 0.8]), array([0.5, 0.6, 0.7, 0.8]), array([0.5, 0.6, 0.7, 0.8])]]
>>> a*c
array([[[ 0.1,  0.4,  0.9,  1.6],
        [ 0.5,  1.2,  2.1,  3.2],
        [ 0.9,  2. ,  3.3,  4.8]],

       [[ 6.5,  8.4, 10.5, 12.8],
        [ 8.5, 10.8, 13.3, 16. ],
        [10.5, 13.2, 16.1, 19.2]]])
>>> a*b
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: operands could not be broadcast together with shapes (2,3,4) (2,4)
>>> a*b[:,np.newaxis,:]
array([[[ 0.1,  0.4,  0.9,  1.6],
        [ 0.5,  1.2,  2.1,  3.2],
        [ 0.9,  2. ,  3.3,  4.8]],

       [[ 6.5,  8.4, 10.5, 12.8],
        [ 8.5, 10.8, 13.3, 16. ],
        [10.5, 13.2, 16.1, 19.2]]])
        
        newaxis对应的维度不变，在这个维度以相同的系数相乘。雷达机翼系统公用同一个参数。
        看成一排都是64，W是1个占3个，dz里面是1个占1个，对应相乘，再相加压缩。


## 2022.7.11

### 平均池化
![10a056e13b0e3bbd1642a7bf6c33845](https://user-images.githubusercontent.com/64791841/178184339-3d248fb2-3348-4b85-a687-c75b42975ff5.png)

在反向传播时，梯度是按位传播的，那么，一个解决方法，就是如何构造按位的问题，但一定要遵守传播梯度总和保持不变的原则。对于平均池化，其前向传播是取某特征区域的平均值进行输出，这个区域的每一个神经元都是有参与前向传播了的，因此，在反向传播时，框架需要将梯度平均分配给每一个神经元再进行反向传播，相关的操作示意如下图所示。


### 最大池化
![30c79b8c54096a5d69b35b4ab731c7a](https://user-images.githubusercontent.com/64791841/178184399-3aa7b4e0-5e47-48eb-a3f0-654e17c4d5da.png)

对于最大池化，其前向传播是取某特征区域的最大值进行输出，这个区域仅有最大值神经元参与了前向传播，因此，在反向传播时，框架仅需要将该区域的梯度直接分配到最大值神经元即可，其他神经元的梯度被分配为0且是被舍弃不参与反向传播的，但如何确认最大值神经元，这个还得框架在进行前向传播时记录下最大值神经元的Max ID位置，这是最大池化与平均池化差异的地方，相关的操作示意如下图所示。

 
 通道与通道之间井水不犯河水，进行各自的池化操作。
